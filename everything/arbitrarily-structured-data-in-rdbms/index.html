<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>shazow | Andrey Petrov</title>

    <link href="https://shazow.net/css/base.css?4" media="screen" rel="stylesheet" type="text/css" />
    <link rel="icon" type="image/png" href="https://shazow.net/images/icon.png" />

    <link rel="alternate" type="application/rss+xml" title="RSS Feed shazow.net" href="https://shazow.net/index.xml" />

    <link href='//fonts.googleapis.com/css?family=OFL+Sorts+Mill+Goudy+TT:400,400italic&amp;v2' rel='stylesheet' type='text/css'>
    
</head>


<body>


<div class="back">&larr; <a href="https://shazow.net/">Back to shazow.net</a></div>
<section class="main post container">
    <div class="front-matter">
        <div class="title-container">
            <div class="initials"><a href="https://shazow.net/"></a></div>
        </div>
        <div class="meta">
            
            <div class="date" title='Wed Oct 20 2010 16:01:53 PDT'>Published on Oct 20, 2010.</div>
            
        </div>
    </div>
    <div>
        <h1 id="arbitrarily-structured-data-in-relational-databases">Arbitrarily-Structured Data in Relational Databases</h1>
<p>This approach is similar to <a href="http://bret.appspot.com/entry/how-friendfeed-uses-mysql">FriendFeed's schemaless database framework</a>. The key difference is in the data locality.</p>
<p>The goal is <em>not</em> to build an effective schemaless database on top of a relational database, but rather to accomodate for rapidly-evolving relational schemas and reducing the difficult of migrating forward.</p>
<h2 id="hypothesis">Hypothesis</h2>
<p>In an evolving relational (SQL) database schema, we store two types of data: Data we will be querying against and data we will be displaying. There is often a subset of display data which will not be used for querying in the foreseeable future, and this is the data whose structure changes most often.</p>
<h2 id="solution">Solution</h2>
<p>Store query data and display data separately such that display data is less strictly-structured and thus more easily evolved.</p>
<p>Imagine a standardized table structure where each table has the following columns: <code>id</code>, <code>time_created</code>, <code>time_updated</code>, <code>_data</code>, and additional &ldquo;index columns&rdquo;.</p>
<p>The <code>_data</code> column contains a dictionary of arbitrary data serialized into JSON (or could be zlib-compressed Pickle if it were Python-specific). Index columns are columns which you query against.</p>
<h3 id="example">Example</h3>
<p>A typical <em>user</em> table might have the following columns (using an SQLAlchemy declarative model):</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">)</span><span class="p">:</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">time_created</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">time_updated</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">onupdate</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>

    <span class="n">is_admin</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">display_name</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="p">)</span>

    <span class="n">password_hash</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">password_salt</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div><p>In our example, this table will have two types of queries:</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="c1">-- Load the user object from the current session (where we store the user_id)
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">user_id</span><span class="p">;</span>

<span class="c1">-- Check the given password against the email address, for login
</span><span class="c1"></span><span class="k">SELECT</span> <span class="n">password_hash</span><span class="p">,</span> <span class="n">password_salt</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">email</span> <span class="o">=</span> <span class="p">:</span><span class="n">user_email</span><span class="p">;</span>
</code></pre></div><p>In the schemaless model, the table would look like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">SchemalessModel</span><span class="p">)</span><span class="p">:</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">time_created</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">time_updated</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">DateTime</span><span class="p">,</span> <span class="n">onupdate</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">JSON</span><span class="p">)</span>

    <span class="n">email</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div><p>Where the <code>_data</code> column would contain data like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
    <span class="s2">&#34;display_name&#34;</span><span class="o">:</span> <span class="s2">&#34;Andrey Petrov&#34;</span><span class="p">,</span>
    <span class="s2">&#34;is_admin&#34;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&#34;password_hash&#34;</span><span class="o">:</span> <span class="s2">&#34;cSKSsy315E4EroxeDQrsxjTb6ijBxxbK&#34;</span><span class="p">,</span>
    <span class="s2">&#34;password_salt&#34;</span><span class="o">:</span> <span class="s2">&#34;vS5Otm&#34;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>And perhaps we would build a framework on top of SQLAlchemy which would let us access columns as <code>user.display_name</code> or <code>user.email</code> regardless whether it's an extracted indexed property or a buried _data element.</p>
<h3 id="process-adding-an-index">Process: Adding an index</h3>
<ol>
<li>Build a table with just a free-structure <code>_data</code> field.</li>
<li>Determine queries, extract relevant properties into indexed columns:
<ol>
<li>ALTER TABLE to add the column</li>
<li>Run full-scan query to populate new column with data</li>
<li>Add relevant index onto said column</li>
<li>Deprecate property from <code>_data</code> (optional, we could just assume that proper columns always supercede <code>_data</code> attributes)</li>
</ol>
</li>
</ol>
<h2 id="concerns">Concerns</h2>
<ul>
<li>Adding an index may affect database performance during the process, due to the data locality. With FriendFeed's approach, the indices are stored in their own tables which could even be sharded across databases, so this removes any performance concerns during schema transitions. On the other hand, FriendFeed's approach reduces data locality which increases the number of joins required to get desired data, and also reduces the semantic meaning of the tables thus making queries more complex.</li>
<li>Performing unexpected demographic analysis on large datasets would be much slower if the fields are stored in <code>_data</code> (such as age, gender, etc) since it would require a full table scan instead of an in-database aggregate query.</li>
<li>Parsing and storing the <code>_data</code> dictionary has some performance implications, too. cPickle is best for parsing performance, perhaps zlib-compressed cPickle is best for data size and parsing performance tradeoff, but no portability beyond Python. zlib-compressed JSON reduces data size and is portable across languages, but increases parsing time. Also, this could be done natively for <a href="http://www.postgresql.org/docs/current/static/hstore.html">PostgreSQL using HSTORE</a> (<a href="http://twitter.com/#!/__jek__/status/27975347844">via <strong>jek</strong></a>)</li>
<li>Tracking mutability is important, potentially hard to do elegantly.</li>
</ul>

    </div>
</section>
<div class="back">&larr; <a href="https://shazow.net/">Back to shazow.net</a></div>


<script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    if (document.location.hostname != 'localhost') {
        ga('create', 'UA-407051-1', 'shazow.net');
    }

    ga('send', 'pageview');
</script>



</body>

</html>

